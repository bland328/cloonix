diff -Naur dpdk-19.02/drivers/bus/ifpga/ifpga_bus.c dpdk_tainted/drivers/bus/ifpga/ifpga_bus.c
--- dpdk-19.02/drivers/bus/ifpga/ifpga_bus.c	2019-02-01 15:25:17.000000000 +0100
+++ dpdk_tainted/drivers/bus/ifpga/ifpga_bus.c	2019-04-27 17:51:13.332756741 +0200
@@ -298,23 +298,29 @@
 	if (afu_dev == NULL)
 		return -1;
 
+RTE_LOG(INFO, EAL, "AAAAAAAAAAAAAAAAAA %d", __LINE__); 
 	/* Check if a driver is already loaded */
 	if (rte_dev_is_probed(&afu_dev->device)) {
 		IFPGA_BUS_DEBUG("Device %s is already probed\n",
 				rte_ifpga_device_name(afu_dev));
 		return -EEXIST;
 	}
+RTE_LOG(INFO, EAL, "AAAAAAAAAAAAAAAAAA %d", __LINE__); 
 
 	TAILQ_FOREACH(drv, &ifpga_afu_drv_list, next) {
+RTE_LOG(INFO, EAL, "AAAAAAAAAAAAAAAAAA %d", __LINE__); 
 		ret = ifpga_probe_one_driver(drv, afu_dev);
 		if (ret < 0)
 			/* negative value is an error */
 			return ret;
+RTE_LOG(INFO, EAL, "AAAAAAAAAAAAAAAAAA %d", __LINE__); 
 		if (ret > 0)
 			/* positive value means driver doesn't support it */
 			continue;
+RTE_LOG(INFO, EAL, "AAAAAAAAAAAAAAAAAA %d", __LINE__); 
 		return 0;
 	}
+RTE_LOG(INFO, EAL, "AAAAAAAAAAAAAAAAAA %d %d", __LINE__, ret); 
 	if ((ret > 0) && (afu_dev->driver == NULL))
 		return 0;
 	else
@@ -337,7 +343,7 @@
 		if (ret == -EEXIST)
 			continue;
 		if (ret < 0)
-			IFPGA_BUS_ERR("failed to initialize %s device\n",
+			IFPGA_BUS_ERR("AAAAAAAAfailed to initialize %s device\n",
 				rte_ifpga_device_name(afu_dev));
 	}
 
diff -Naur dpdk-19.02/drivers/bus/vdev/vdev.c dpdk_tainted/drivers/bus/vdev/vdev.c
--- dpdk-19.02/drivers/bus/vdev/vdev.c	2019-02-01 15:25:17.000000000 +0100
+++ dpdk_tainted/drivers/bus/vdev/vdev.c	2019-04-27 17:59:26.598407442 +0200
@@ -121,7 +121,11 @@
 	struct rte_vdev_driver **out = addr;
 	struct rte_vdev_driver *driver = NULL;
 
+VDEV_LOG(ERR, "IIIIIIIIIIIIIIIIIIIIIIII %s %p", name, addr); 
 	TAILQ_FOREACH(driver, &vdev_driver_list, next) {
+VDEV_LOG(ERR, "driver->driver.name %s", driver->driver.name); 
+if(driver->driver.alias)
+VDEV_LOG(ERR, "driver->driver.alias %s", driver->driver.alias); 
 		if (strncmp(driver->driver.name, name,
 			    strlen(driver->driver.name)) == 0)
 			break;
@@ -145,14 +149,23 @@
 
 	name = rte_vdev_device_name(dev);
 
-	VDEV_LOG(DEBUG, "Search driver %s to probe device %s", name,
+VDEV_LOG(ERR, "Search driver %s to probe device %s", name,
 		rte_vdev_device_name(dev));
 
 	if (vdev_parse(name, &driver))
+           {
+VDEV_LOG(ERR, "PARSEPB driver %s to probe device %s", name,
+		rte_vdev_device_name(dev));
 		return -1;
+           }
 	ret = driver->probe(dev);
 	if (ret == 0)
 		dev->device.driver = &driver->driver;
+else
+{
+VDEV_LOG(ERR, "PROBEPB driver %s to probe device %s", name,
+		rte_vdev_device_name(dev));
+}
 	return ret;
 }
 
@@ -495,7 +508,7 @@
 			continue;
 
 		if (vdev_probe_all_drivers(dev)) {
-			VDEV_LOG(ERR, "failed to initialize %s device",
+			VDEV_LOG(ERR, "OOOOOOOOfailed to initialize %s device",
 				rte_vdev_device_name(dev));
 			ret = -1;
 		}
diff -Naur dpdk-19.02/lib/librte_eal/common/eal_common_dev.c dpdk_tainted/lib/librte_eal/common/eal_common_dev.c
--- dpdk-19.02/lib/librte_eal/common/eal_common_dev.c	2019-02-01 15:25:17.000000000 +0100
+++ dpdk_tainted/lib/librte_eal/common/eal_common_dev.c	2019-04-27 17:51:13.332756741 +0200
@@ -196,21 +196,27 @@
 	struct rte_device *dev;
 	int ret;
 
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 	memset(&req, 0, sizeof(req));
 	req.t = EAL_DEV_REQ_TYPE_ATTACH;
 	strlcpy(req.devargs, devargs, EAL_DEV_MP_DEV_ARGS_MAX_LEN);
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 
 	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
+
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 		/**
 		 * If in secondary process, just send IPC request to
 		 * primary process.
 		 */
 		ret = eal_dev_hotplug_request_to_primary(&req);
 		if (ret != 0) {
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 			RTE_LOG(ERR, EAL,
 				"Failed to send hotplug request to primary\n");
 			return -ENOMSG;
 		}
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 		if (req.result != 0)
 			RTE_LOG(ERR, EAL,
 				"Failed to hotplug add device\n");
@@ -218,10 +224,12 @@
 	}
 
 	/* attach a shared device from primary start from here: */
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 
 	/* primary attach the new device itself. */
 	ret = local_dev_probe(devargs, &dev);
 
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 	if (ret != 0) {
 		RTE_LOG(ERR, EAL,
 			"Failed to attach device on primary process\n");
@@ -236,9 +244,11 @@
 			return ret;
 	}
 
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 	/* primary send attach sync request to secondary. */
 	ret = eal_dev_hotplug_request_to_secondary(&req);
 
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 	/* if any communication error, we need to rollback. */
 	if (ret != 0) {
 		RTE_LOG(ERR, EAL,
@@ -246,6 +256,7 @@
 		ret = -ENOMSG;
 		goto rollback;
 	}
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 
 	/**
 	 * if any secondary failed to attach, we need to consider if rollback
@@ -261,6 +272,7 @@
 			return ret;
 		goto rollback;
 	}
+RTE_LOG(ERR, EAL, "OOOOOOO %s %d\n", __FUNCTION__, __LINE__);
 
 	return 0;
 
diff -Naur dpdk-19.02/lib/librte_eal/linuxapp/eal/eal.c dpdk_tainted/lib/librte_eal/linuxapp/eal/eal.c
--- dpdk-19.02/lib/librte_eal/linuxapp/eal/eal.c	2019-02-01 15:25:17.000000000 +0100
+++ dpdk_tainted/lib/librte_eal/linuxapp/eal/eal.c	2019-04-27 17:51:13.332756741 +0200
@@ -109,13 +109,13 @@
 	char tmp[PATH_MAX];
 	int ret;
 
-	if (getuid() != 0) {
+//cloonix	if (getuid() != 0) {
 		/* try XDG path first, fall back to /tmp */
 		if (xdg_runtime_dir != NULL)
 			directory = xdg_runtime_dir;
 		else
 			directory = fallback;
-	}
+//cloonix	}
 	/* create DPDK subdirectory under runtime dir */
 	ret = snprintf(tmp, sizeof(tmp), "%s/dpdk", directory);
 	if (ret < 0 || ret == sizeof(tmp)) {
diff -Naur dpdk-19.02/lib/librte_ethdev/rte_ethdev.c dpdk_tainted/lib/librte_ethdev/rte_ethdev.c
--- dpdk-19.02/lib/librte_ethdev/rte_ethdev.c	2019-02-01 15:25:17.000000000 +0100
+++ dpdk_tainted/lib/librte_ethdev/rte_ethdev.c	2019-04-27 17:51:13.332756741 +0200
@@ -442,6 +442,7 @@
 	uint16_t port_id;
 	struct rte_eth_dev *eth_dev = NULL;
 
+RTE_ETHDEV_LOG(ERR, "OOOOOOOOOOO %s\n", name);
 	rte_eth_dev_shared_data_prepare();
 
 	/* Synchronize port creation between primary and secondary threads. */
@@ -454,20 +455,24 @@
 		goto unlock;
 	}
 
+RTE_ETHDEV_LOG(ERR, "OOOOOOOOOOO %s\n", name);
 	port_id = rte_eth_dev_find_free_port();
 	if (port_id == RTE_MAX_ETHPORTS) {
 		RTE_ETHDEV_LOG(ERR,
 			"Reached maximum number of Ethernet ports\n");
 		goto unlock;
 	}
+RTE_ETHDEV_LOG(ERR, "OOOOOOOOOOO %s\n", name);
 
 	eth_dev = eth_dev_get(port_id);
 	snprintf(eth_dev->data->name, sizeof(eth_dev->data->name), "%s", name);
 	eth_dev->data->port_id = port_id;
 	eth_dev->data->mtu = ETHER_MTU;
+RTE_ETHDEV_LOG(ERR, "OOOOOOOOOOO %s\n", name);
 
 unlock:
 	rte_spinlock_unlock(&rte_eth_dev_shared_data->ownership_lock);
+RTE_ETHDEV_LOG(ERR, "OOOOOOOOOOO %s\n", name);
 
 	return eth_dev;
 }
